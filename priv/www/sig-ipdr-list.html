<!--  vim: set ts=3:  -->
<link rel="import" href="polymer/polymer.html">
<link rel="import" href="i18n-msg/i18n-msg-behavior.html">
<link rel="import" href="vaadin-grid/vaadin-grid.html">
<link rel="import" href="vaadin-grid/vaadin-grid-filter.html">
<link rel="import" href="vaadin-grid/vaadin-grid-sorter.html">

<dom-module id="sig-ipdr-list">
	<template>
		<style>
			::-webkit-input-placeholder { /* Chrome/Opera/Safari */
				color: initial;
				font-weight: bold;
			}
			::-moz-placeholder { /* Firefox 19+ */
				color: initial;
				font-weight: bold;
			}
			:-ms-input-placeholder { /* IE 10+ */
				color: initial;
				font-weight: bold;
			}
			:-moz-placeholder { /* Firefox 18- */
				color: initial;
				font-weight: bold;
			}
			vaadin-grid {
				height: 100%;
				--vaadin-grid-header-cell: {
					background: #ffb04c;
				};
			}
			vaadin-grid input {
				font-size: inherit;
				background: #ffb04c;
				border-style: none;
			}
			.yellow-button {
				text-transform: none;
				color: #eeff41;
			}
		</style>
		<vaadin-grid id="ipdrGrid">
			<vaadin-grid-column width="19ex" flex-grow="1">
				<template class="header">
					<vaadin-grid-sorter path="ipdrCreationTime">
						<vaadin-grid-filter aria-label="[[i18n.creationTime]]" path="ipdrCreationTime" value="[[_filterIPDRCreationTime]]">
							<input placeholder="[[i18n.creationTime]]" value="{{_filterIPDRCreationTime::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.ipdrCreationTime]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="4ex">
				<template class="header">[[i18n.seq]]</template>
				<template>[[item.seqNum]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="20ex" flex-grow="4">
				<template class="header">
					<vaadin-grid-sorter path="username">
						<vaadin-grid-filter aria-label="[[i18n.userName]]" path="username" value="[[_filterUserName]]">
							<input placeholder="[[i18n.userName]]" value="{{_filterUserName::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.username]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="12ex" flex-grow="0">
				<template class="header">
					<vaadin-grid-sorter path="acctSessionId">
						<vaadin-grid-filter aria-label="[[i18n.acctSessionId]]" path="acctSessionId" value="[[_filterAcctSessionId]]">
							<input placeholder="[[i18n.acctSessionId]]" value="{{_filterAcctSessionId::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.acctSessionId]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="20ex" flex-grow="3">
				<template class="header">
					<vaadin-grid-sorter path="callingStationId">
						<vaadin-grid-filter aria-label="[[i18n.callingStationId]]" path="callingStationId" value="[[_filterCallingStationId]]">
							<input placeholder="[[i18n.callingStationId]]" value="{{_filterCallingStationId::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.callingStationId]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="28ex" flex-grow="3">
				<template class="header">
					<vaadin-grid-sorter path="calledStationId">
						<vaadin-grid-filter aria-label="[[i18n.calledStationId]]" path="calledStationId" value="[[_filterCalledStationId]]">
							<input placeholder="[[i18n.calledStationId]]" value="{{_filterCalledStationId::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.calledStationId]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="16ex" flex-grow="2">
				<template class="header">
					<vaadin-grid-sorter path="nasIpAddress">
						<vaadin-grid-filter aria-label="[[i18n.nasIpAddress]]" path="nasIpAddress" value="[[_filterNasIpAddress]]">
							<input placeholder="[[i18n.nasIpAddress]]" value="{{_filterNasIpAddress::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.nasIpAddress]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="12ex" flex-grow="4">
				<template class="header">
					<vaadin-grid-sorter path="nasId">
						<vaadin-grid-filter aria-label="[[i18n.nasID]]" path="nasId" value="[[_filterNasId]]">
							<input placeholder="[[i18n.nasID]]" value="{{_filterNasId::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.nasId]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="9ex" flex-grow="2">
				<template class="header">
					<vaadin-grid-sorter path="sessionDuration">[[i18n.sessionDur]]</vaadin-grid-sorter>
				</template>
				<template>[[item.sessionDuration]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="12ex" flex-grow="2">
				<template class="header">
					<vaadin-grid-sorter path="inputOctets">[[i18n.inputOctets]]</vaadin-grid-sorter>
				</template>
				<template>[[item.inputOctets]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="13ex" flex-grow="2">
				<template class="header">
					<vaadin-grid-sorter path="outputOctets">[[i18n.outputOctets]]</vaadin-grid-sorter>
				</template>
				<template>[[item.outputOctets]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="19ex" flex-grow="1">
				<template class="header">
					<vaadin-grid-sorter path="gmtSessionStartDateTime">
						<vaadin-grid-filter aria-label="[[i18n.gmtSessionStartDateTime]]" path="gmtSessionStartDateTime" value="[[_filterGmtSessionStartDateTime]]">
							<input placeholder="[[i18n.gmtSessionStartDateTime]]" value="{{_filterGmtSessionStartDateTime::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.gmtSessionStartDateTime]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="19ex" flex-grow="1">
				<template class="header">
					<vaadin-grid-sorter path="gmtSessionEndDateTime">
						<vaadin-grid-filter aria-label="[[i18n.gmtSessionendtime]]" path="gmtSessionEndDateTime" value="[[_filterGmtSessionEndDateTime]]">
							<input placeholder="[[i18n.gmtSessionendtime]]" value="{{_filterGmtSessionEndDateTime::input}}" focus-target>
						</vaadin-grid-filter>
					</vaadin-grid-sorter>
				</template>
				<template>[[item.gmtSessionEndDateTime]]</template>
			</vaadin-grid-column>
			<vaadin-grid-column width="5ex">
				<template class="header">
					<vaadin-grid-filter aria-label="[[i18n.SessionTerminateCause]]" path="sessionTerminateCause" value="[[_filterSessionTerminateCause]]">
						<input Placeholder="[[i18n.SessionTerminateCause]]" value="{{_filterSessionTerminateCause::input}}" focus-target>
					</vaadin-grid-filter>
				</template>
				<template>[[item.sessionTerminateCause]]</template>
			</vaadin-grid-column>
		</vaadin-grid/>
		<paper-toast
			id="addLogToastError"
			text="Log error">
		</paper-toast>
		<paper-toast
			id="addLogContentToastError"
			text="Log content error">
		</paper-toast>
		<paper-toast id="ipdrErrorToast" duration="0">
			<paper-button
					class="yellow-button"
					onclick="ipdrErrorToast.toggle()">
				Close
			</paper-button>
		</paper-toast>
		<iron-ajax id="getIpdr"
				headers='{"Accept": "application/json"}'
				on-loading-changed="_onLoadingChanged"
				on-response="getLogContentResponse"
				on-error="getLogContentError">
		</iron-ajax>
	</template>
	<script>
		Polymer ({
			is: 'sig-ipdr-list',
			behaviors: [i18nMsgBehavior],
			properties: {
				activePage: {
					type: Boolean,
					value: false,
					observer: '_activePageChanged'
				}
			},
			_activePageChanged: function(active) {
				if (active) {
					document.getElementById("getLogsAjax").generateRequest();
					document.getElementById("selectLogFileModal").open();
				}
			},
			_onLoadingChanged: function(event) {
				if (this.$.getIpdr.loading) {
					document.getElementById("progress").disabled = false;
				} else {
					document.getElementById("progress").disabled = true;
				}
			},
			getLogContentResponse: function(event) {
				document.getElementById("selectLogFileModal").close();
				var grid = this.$.ipdrGrid;
				var results = event.detail.response;
				vaadinItems = new Array();
				for(var index in results) {
						var newRecord = new Object();
						newRecord.date = results[index].date;
						newRecord.type = results[index].type;
						newRecord.usageSpecificationName = results[index].usageSpecification.name;
						results[index].usageCharacteristic.forEach(
							function(attrObj) {
								if(attrObj.value == "undefined") {
									attrObj.value = '';
									newRecord[attrObj.key] = attrObj.value;
								} else {
									newRecord[attrObj.key] = attrObj.value;
								}
							}
						);
						vaadinItems[index] = newRecord;
				}
				grid.frozenColumns = 1;
				grid.items = vaadinItems;
				grid.columns = [
					{
						"name": "ipdrCreationTime"
					},
					{
						"name": "seqNum"
					},
					{
						"name": "username"
					},
//							{
//								"name": "scIdType"
//							},
//							{
//								"name": "scId"
//							},
//							{
//								"name": "homeServiceProviderType"
//							},
//							{
//								"name": "homeServiceProvider"
//							},
					{
						"name": "acctSessionId"
					},
//							{
//								"name": "userIpAddress"
//							},
					{
						"name": "callingStationId"
					},
					{
						"name": "calledStationId"
					},
					{
						"name": "nasIpAddress"
					},
					{
						"name": "nasId"
					},
//							{
//								"name": "accessProviderType"
//							},
//							{
//								"name": "accessServiceProvider"
//							},
//							{
//								"name": "locationName"
//							},
//							{
//								"name": "locationId"
//							},
//							{
//								"name": "locationType"
//							},
//							{
//								"name": "locationCountryCode"
//							},
//							{
//								"name": "locationStateProvince"
//							},
//							{
//								"name": "locationCity"
//							},
//							{
//								"name": "locationGeocode"
//							},
//							{
//								"name": "locationGeocodeType"
//							},
//							{
//								"name": "nasPortType"
//							},
//							{
//								"name": "paymentType"
//							},
//							{
//								"name": "networkConnectionType"
//							},
					{
						"name": "sessionDuration"
					},
					{
						"name": "inputOctets"
					},
					{
						"name": "outputOctets"
					},
//							{
//								"name": "class"},
//							},
					{
						"name": "gmtSessionStartDateTime"
					},
					{
						"name": "gmtSessionEndDateTime"
					},
					{
						"name": "sessionTerminateCause"
					}
//							{
//								"name": "billingClassOfService"
//							},
//							{
//								"name": "unitOfMeasure"
//							},
//							{
//								"name": "chargeableUnit"
//							},
//							{
//								"name": "chargeableQuantity"
//							},
//							{
//								"name": "chargeAmount"
//							},
//							{
//								"name": "chargeCurrencyType"
//							},
//							{
//								"name": "otherParty"
//							},
//							{
//								"name": "taxPercentage"
//							},
//							{
//								"name": "taxAmount"
//							},
//							{
//								"name": "taxType"
//							},
//							{
//								"name": "intermediaryName"
//							},
//							{
//								"name": "serviceName"
//							},
//							{
//								"name": "relatedIpdrIdList"
//							},
//							{
//								"name": "tempUserId"
//							}
				];
			},
			getLogContentError: function(event) {
				this.$.addLogContentToastError.text = event.detail.request.xhr.statusText;
				this.$.addLogContentToastError.open();
			}
		});
	</script>
</dom-module>
